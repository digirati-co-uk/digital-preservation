using DigitalPreservation.Common.Model;
using DigitalPreservation.Utils;
using Microsoft.Extensions.Options;

namespace Storage.API.Fedora.Model;

public class Converters
{
    private readonly FedoraOptions fedoraOptions;
    private readonly ConverterOptions converterOptions;
    
    private readonly string fedoraRoot;
    private readonly string fedoraRootWithoutSlash;
    private readonly Uri fedoraRootUri;
    private readonly Uri fedoraRootUriWithoutSlash;
    private readonly string repositoryRoot;
    private readonly string contentRoot;
    private readonly string fedoraAgentRoot; // Not sure what this is going to be yet
    private readonly string agentRoot;
    private readonly Uri agentRootUri;
    private readonly string transientRoot;
    private readonly string importRoot;
    private readonly string exportRoot;
    private readonly string activityRoot;

    // We could register the vocab with Fedora and alias the type
    // But this will always work without having to do anything special to Fedora.
    // The only thing to watch out for here is if Fedora starts using this type in the future.
    // TODO: Consider minting our own URI for ArchivalGroupRdfType
    public const string ArchivalGroupRdfType = "http://purl.org/dc/dcmitype/Collection";

    
    public Converters(IOptions<FedoraOptions> fedoraOptions, IOptions<ConverterOptions> converterOptions)
    {
        this.fedoraOptions = fedoraOptions.Value;
        this.converterOptions = converterOptions.Value;
        fedoraRootUri = fedoraOptions.Value.Root;
        fedoraRootUriWithoutSlash = new Uri(fedoraOptions.Value.Root.ToString().TrimEnd('/'));
        fedoraRoot = fedoraOptions.Value.Root.ToString();
        fedoraRootWithoutSlash = fedoraRoot.TrimEnd('/');
        
        // The root URI for repository paths
        repositoryRoot = $"{converterOptions.Value.StorageRoot}repository/";
        
        // The root URI for binary streams from Fedora
        contentRoot = $"{converterOptions.Value.StorageRoot}content/";
        
        fedoraAgentRoot = fedoraOptions.Value.Root.ToString(); // make it same for now
        
        // The root URI for people and other API callers
        agentRoot = $"{converterOptions.Value.StorageRoot}agents/";
        agentRootUri = new Uri(agentRoot);
        
        // Use this for JSON responses that need an id, but are not recoverable from that id.
        // Example - a diff import job generated by the storage API is transient
        transientRoot = $"{converterOptions.Value.StorageRoot}transient/";
        
        //  The path used by the Storage API to import to an archival group
        // import/archival/group/path
        importRoot = $"{converterOptions.Value.StorageRoot}import/";
        
        // Root of export resources (can be used to check status)
        exportRoot = $"{converterOptions.Value.StorageRoot}export/";
        
        // Change Discovery endpoints root
        activityRoot = $"{converterOptions.Value.StorageRoot}activity/";
    }
    
    public ArchivalGroup MakeArchivalGroup(FedoraJsonLdResponse fedoraJsonLdResponse)
    {
        var archivalGroup = new ArchivalGroup();
        PopulateBaseFields(archivalGroup, fedoraJsonLdResponse);
        return archivalGroup;
    }
    
    public Binary MakeBinary(BinaryMetadataResponse binaryMetadataResponse)
    {
        var binary = new Binary();
        PopulateBaseFields(binary, binaryMetadataResponse);
        binary.ContentType = binaryMetadataResponse.ContentType;
        binary.Size = Convert.ToInt64(binaryMetadataResponse.Size);
        binary.Digest = binaryMetadataResponse.Digest?.Split(':')[^1];
        binary.Content = ConvertToContentUri(binaryMetadataResponse.Id);
        return binary;
    }
    
    public Container MakeContainer(FedoraJsonLdResponse fedoraJsonLdResponse)
    {
        var container = new Container();
        SetType(container, fedoraJsonLdResponse);
        PopulateBaseFields(container, fedoraJsonLdResponse);
        return container;
    }

    private static void SetType(Container container, FedoraJsonLdResponse fedoraJsonLdResponse)
    {
        if (fedoraJsonLdResponse.Type == null || fedoraJsonLdResponse.Type.Length == 0)
        {
            throw new InvalidOperationException("No type present");
        }
        if (fedoraJsonLdResponse.Type.Contains("fedora:RepositoryRoot"))
        {
            container.Type = "RepositoryRoot";
        }
        else if (fedoraJsonLdResponse.Type.Contains(ArchivalGroupRdfType))
        {
            container.Type = "ArchivalGroup";
        }
        else
        {
            container.Type = "Container";
        }
    }


    
    private void PopulateBaseFields(PreservedResource resource, FedoraJsonLdResponse fedoraJsonLdResponse)
    {
        resource.Id = ConvertToRepositoryUri(fedoraJsonLdResponse.Id);
        resource.Name = fedoraJsonLdResponse.Title ?? resource.Id.GetSlug();
        resource.Created = fedoraJsonLdResponse.Created;
        resource.CreatedBy = ConvertToAgentUri(fedoraJsonLdResponse.CreatedBy);
        resource.LastModified = fedoraJsonLdResponse.LastModified;
        resource.LastModifiedBy = ConvertToAgentUri(fedoraJsonLdResponse.LastModifiedBy);
    }

    public Uri ConvertToRepositoryUri(Uri fedoraUri)
    {
        var repositoryUri = fedoraUri.ToString().ReplaceFirst(fedoraRoot, repositoryRoot);
        return new Uri(repositoryUri);
    }
    
    public Uri ConvertToContentUri(Uri fedoraUri)
    {
        var contentUri = fedoraUri.ToString().ReplaceFirst(fedoraRoot, contentRoot);
        return new Uri(contentUri);
    }

    public Uri RepositoryUriFromPathUnderRoot(string pathUnderRoot)
    {
        return new Uri(repositoryRoot + pathUnderRoot);
    }

    public Uri GetAgentUri(string identitySlug)
    {
        return new Uri(agentRoot + identitySlug);
    }
    
    public Uri ActivityUri(string path)
    {
        return new Uri(activityRoot + path);
    }

    private Uri? ConvertToAgentUri(string? fedoraAgentUri)
    {
        if (fedoraAgentUri.IsNullOrWhiteSpace()) return null;
        
        var agentUri = fedoraAgentUri.ReplaceFirst(fedoraAgentRoot, agentRoot);
        if (agentUri == fedoraAgentUri)
        {
            return new Uri(agentRootUri, agentUri);
        }
        return new Uri(agentUri);
    }

    internal Uri GetFedoraUri(string? pathUnderFedoraRoot)
    {
        return new Uri(fedoraOptions.Root, pathUnderFedoraRoot);
    }

    public string GetFedoraDbId(string? pathUnderFedoraRoot)
    {
        if (pathUnderFedoraRoot.HasText())
        {
            return "info:fedora/" + pathUnderFedoraRoot;
        }

        return "info:fedora";
    }    
    
    public Uri RepositoryUriFromDbId(string dbId)
    {
        return new Uri(repositoryRoot + dbId.RemoveStart("info:fedora/"));
    }

    public string GetFedoraDbId(Uri fedoraUri)
    {
        var fedoraUriString = fedoraUri.ToString();
        var trimmed = fedoraUriString == fedoraRoot ? string.Empty : fedoraUriString.RemoveStart(fedoraRoot);
        return GetFedoraDbId(trimmed);
    }
    
    public bool IsFedoraRoot(Uri uri)
    {
        return uri == fedoraRootUri || uri == fedoraRootUriWithoutSlash;
    }

    /// <summary>
    /// Use this for JSON responses that need an id, but are not recoverable from that id.
    /// Example - a diff import job generated by the storage API is transient
    /// </summary>
    /// <returns></returns>
    public Uri GetTransientResourceId(string? prefix = null)
    {
        return new Uri(transientRoot + (prefix == null ? "" : prefix + "/") + Guid.NewGuid());
    }

    public Uri GetStorageImportJobResultId(string archivalGroupPathUnderRoot, string jobIdentifier)
    {
        return new Uri($"{importRoot}results/{jobIdentifier}/{archivalGroupPathUnderRoot}");
    }

    public Uri GetExportResultId(string identifier)
    {
        return new Uri($"{exportRoot}{identifier}");
    }

    public string? GetResourcePathPart(Uri fedoraOrStorageUri)
    {
        var s = fedoraOrStorageUri.ToString();
        if (s.StartsWith(fedoraRoot))
        {
            return s.RemoveStart(fedoraRoot)!;
        }
        if (s.StartsWith(repositoryRoot))
        {
            return s.RemoveStart(repositoryRoot)!;
        }
        return null;
    }
}